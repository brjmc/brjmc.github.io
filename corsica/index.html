<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GR20 Route Planner – Advanced Edition</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <!-- Chart.js CSS (optional) -->
  <style>
    /* Basic styling */
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background: #fafafa;
      color: #333;
    }
    .container {
      max-width: 960px;
      margin: 20px auto;
      padding: 0 10px;
    }
    h1, h2 {
      text-align: center;
    }
    label, select, button {
      font-size: 16px;
    }
    select, button {
      padding: 8px;
      margin: 5px auto;
      display: block;
      cursor: pointer;
    }
    /* Grid for stops */
    .grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin-bottom: 10px;
    }
    .grid button {
      padding: 6px 10px;
      border: 1px solid #ccc;
      background: #f9f9f9;
      transition: background 0.2s;
    }
    .grid button.selected {
      background: #007BFF;
      color: #fff;
      border-color: #007BFF;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 10px;
    }
    th, td {
      border: 1px solid #ddd;
      padding: 6px;
      text-align: center;
      font-size: 14px;
    }
    th {
      background: #f2f2f2;
    }
    /* Map styling */
    #map {
      height: 400px;
      margin: 20px 0;
    }
    /* Chart container */
    #chartContainer {
      margin: 20px 0;
    }
    canvas {
      background: #fff;
      border: 1px solid #ccc;
    }
    /* Legend styling */
    .info.legend {
      background: white;
      padding: 6px 8px;
      font: 14px/16px Arial, Helvetica, sans-serif;
      box-shadow: 0 0 15px rgba(0,0,0,0.2);
      border-radius: 5px;
    }
    .info.legend i {
      width: 16px;
      height: 16px;
      float: left;
      margin-right: 8px;
      opacity: 0.9;
      border-radius: 50%;
      border: 2px solid white;
    }
    /* Buttons for GPX Export and Custom Stop */
    .extra-buttons {
      text-align: center;
      margin: 10px 0;
    }
    .extra-buttons button {
      margin: 0 5px;
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
    }
    /* Responsive adjustments */
    @media(max-width:600px){
      th, td { font-size: 12px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>GR20 Route Planner – Advanced Edition</h1>
    <label for="direction">Select Direction:</label>
    <select id="direction" aria-label="Select Direction">
      <option value="N2S" selected>North-to-South (Starts at Calenzana)</option>
      <option value="S2N">South-to-North (Starts at Conca)</option>
    </select>
    <!-- Toggle Button for displaying stops -->
    <button id="toggleStopDisplay" aria-label="Toggle stop display">Show All Stops</button>
    <!-- Extra buttons -->
    <div class="extra-buttons">
      <button id="exportGPX" aria-label="Export GPX">Export GPX</button>
      <button id="addCustomStop" aria-label="Add custom stop">Add Custom Stop</button>
    </div>
    <div class="grid" id="stopGrid"></div>
    <h2>Planned Itinerary</h2>
    <table>
      <thead>
        <tr>
          <th>Day</th>
          <th>Start Stop</th>
          <th>End Stop</th>
          <th>Distance (km)</th>
          <th>Elevation Gain (m)</th>
          <th>Elevation Loss (m)</th>
          <th>Highlights</th>
          <th>Est. Time</th>
        </tr>
      </thead>
      <tbody id="itineraryTable"></tbody>
    </table>
    <!-- Elevation Profile Chart -->
    <div id="chartContainer">
      <canvas id="elevationChart" aria-label="Elevation Profile Chart"></canvas>
      <div id="timeSummary" aria-label="Estimated total hiking time"></div>
    </div>
    <div id="map" aria-label="Map of GR20 Route"></div>
  </div>

  <!-- External libraries: Leaflet and Chart.js -->
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  
  <script>
    /******** Data Setup ********/
    // Original stops from GR20 – adding altitude and dummy booking links.
    const originalStops = [
      { name: "Calenzana", type: "village", lat: 42.5081, lng: 8.8553, alt: 300, origIndex: 0 },
      { name: "Refuge d'Ortu di u Piobbu", type: "refuge", lat: 42.4653, lng: 8.9069, alt: 1520, origIndex: 1, booking: "https://booking.example.com/ortu" },
      { name: "Refuge de Carrozzu", type: "refuge", lat: 42.4262, lng: 8.9005, alt: 1270, origIndex: 2, booking: "https://booking.example.com/carrozzu" },
      { name: "Ascu Stagnu (Haut Asco)", type: "refuge", lat: 42.4035, lng: 8.9223, alt: 1420, origIndex: 3, booking: "https://booking.example.com/ascu" },
      { name: "Refuge de Tighjettu", type: "refuge", lat: 42.3623, lng: 8.9088, alt: 1683, origIndex: 4, booking: "https://booking.example.com/tighjettu" },
      { name: "Refuge de Ciottulu di i Mori", type: "refuge", lat: 42.3350, lng: 8.8681, alt: 1997, origIndex: 5, booking: "https://booking.example.com/ciottulu" },
      { name: "Refuge de Manganu", type: "refuge", lat: 42.2199, lng: 8.9804, alt: 1600, origIndex: 6, booking: "https://booking.example.com/manganu" },
      { name: "Refuge de Petra Piana", type: "refuge", lat: 42.1981, lng: 9.0524, alt: 1842, origIndex: 7, booking: "https://booking.example.com/petra" },
      { name: "Refuge de l'Onda", type: "refuge", lat: 42.1528, lng: 9.0725, alt: 1430, origIndex: 8, booking: "https://booking.example.com/onda" },
      { name: "Vizzavona", type: "village", lat: 42.1286, lng: 9.1333, alt: 1842, origIndex: 9 },
      { name: "Bergeries d'E Capannelle", type: "sheepfold", lat: 42.0779, lng: 9.1497, alt: 1600, origIndex: 10 },
      { name: "Refuge de Prati", type: "refuge", lat: 42.0086, lng: 9.2183, alt: 1820, origIndex: 11, booking: "https://booking.example.com/prati" },
      { name: "Refuge d'Usciolu", type: "refuge", lat: 41.9351, lng: 9.2060, alt: 1750, origIndex: 12, booking: "https://booking.example.com/usciolu" },
      { name: "Refuge d'Asinau", type: "refuge", lat: 41.8415, lng: 9.2144, alt: 1536, origIndex: 13, booking: "https://booking.example.com/asinau" },
      { name: "Refuge de Paliri", type: "refuge", lat: 41.7945, lng: 9.2596, alt: 1055, origIndex: 14, booking: "https://booking.example.com/paliri" },
      { name: "Conca", type: "village", lat: 41.7350, lng: 9.3333, alt: 100, origIndex: 15 }
    ];
    // Extended stops: reindex all stops.
    const stopsN2SExtended = [
      originalStops[0],                  // 0: Calenzana
      originalStops[1],                  // 1: Refuge d'Ortu di u Piobbu
      originalStops[2],                  // 2: Refuge de Carrozzu
      originalStops[3],                  // 3: Ascu Stagnu (Haut Asco)
      originalStops[4],                  // 4: Refuge de Tighjettu
      originalStops[5],                  // 5: Refuge de Ciottulu di i Mori
      originalStops[6],                  // 6: Refuge de Manganu
      { name: "Bergeries d'A Basseta", type: "sheepfold", lat: 42.2150, lng: 8.9850, alt: 1600, origIndex: null },
      originalStops[7],                  // 8: Refuge de Petra Piana (origIndex remains 7)
      originalStops[8],                  // 9: Refuge de l'Onda (origIndex remains 8)
      originalStops[9],                  // 10: Vizzavona (origIndex remains 9)
      originalStops[10],                 // 11: Bergeries d'E Capannelle (origIndex remains 10)
      originalStops[11],                 // 12: Refuge de Prati (origIndex remains 11)
      originalStops[12],                 // 13: Refuge d'Usciolu (origIndex remains 12)
      { name: "Bergeries d'I Croci", type: "sheepfold", lat: 41.8900, lng: 9.2100, alt: 1550, origIndex: null },
      originalStops[13],                 // 15: Refuge d'Asinau (origIndex remains 13)
      originalStops[14],                 // 16: Refuge de Paliri (origIndex remains 14)
      originalStops[15]                  // 17: Conca (origIndex remains 15)
    ];
    // Stage data for the GR20 (15 legs)
    const stagesN2S = [
      { distance: 11, elevationGain: 1450, elevationLoss: 250, highlights: "Calenzana to Refuge d'Ortu di u Piobbu" },
      { distance: 8,  elevationGain: 720,  elevationLoss: 950, highlights: "Ortu di u Piobbu to Refuge de Carrozzu" },
      { distance: 9,  elevationGain: 800,  elevationLoss: 640, highlights: "Carrozzu to Ascu Stagnu" },
      { distance: 9,  elevationGain: 1200, elevationLoss: 1000, highlights: "Ascu Stagnu to Refuge de Tighjettu" },
      { distance: 7,  elevationGain: 700,  elevationLoss: 340, highlights: "Tighjettu to Refuge de Ciottulu di i Mori" },
      { distance: 24, elevationGain: 920,  elevationLoss: 1300, highlights: "Ciottulu di i Mori to Refuge de Manganu" },
      { distance: 8.5, elevationGain: 830,  elevationLoss: 600, highlights: "Manganu to Refuge de Petra Piana" },
      { distance: 10, elevationGain: 390,  elevationLoss: 800, highlights: "Petra Piana to Refuge de l'Onda" },
      { distance: 13, elevationGain: 990,  elevationLoss: 1500, highlights: "L'Onda to Vizzavona" },
      { distance: 16, elevationGain: 1000, elevationLoss: 335,  highlights: "Vizzavona to Bergeries d'E Capannelle" },
      { distance: 14, elevationGain: 320,  elevationLoss: 620,  highlights: "Capannelle to Refuge de Prati" },
      { distance: 16, elevationGain: 1290, elevationLoss: 830,  highlights: "Prati to Refuge d'Usciolu" },
      { distance: 14, elevationGain: 340,  elevationLoss: 640,  highlights: "Usciolu to Refuge d'Asinau" },
      { distance: 9,  elevationGain: 665,  elevationLoss: 545,  highlights: "Asinau to Refuge de Paliri" },
      { distance: 12, elevationGain: 700,  elevationLoss: 1670, highlights: "Paliri to Conca" }
    ];
    let currentDirection = "N2S";
    let stops = [...stopsN2SExtended];
    // Global toggle: if true, show all stops; if false, show only selected stops.
    let showAllStops = true;
    // Array of selected stops (indices); initially only the first stop.
    let selectedStops = [0];
    // Aggregated leg data computed in updateItinerary().
    let aggregatedLegs = [];

    /******** Helper Functions ********/
    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) ** 2 + Math.cos(lat1 * Math.PI/180) * Math.cos(lat2 * Math.PI/180) * Math.sin(dLon/2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }
    // Return icon based on stop type and selection.
    function getIconForType(stop, isSelected) {
      let color;
      if(stop.type === "refuge") {
        color = isSelected ? "red" : "blue";
      } else if(stop.type === "village") {
        color = isSelected ? "black" : "gray";
      } else if(stop.type === "sheepfold") {
        color = isSelected ? "darkorange" : "orange";
      } else if(stop.type === "custom") {
        color = isSelected ? "purple" : "violet";
      } else {
        color = isSelected ? "red" : "blue";
      }
      return L.divIcon({
        className: 'custom-marker',
        html: `<div style="width:16px; height:16px; background-color:${color}; border-radius:50%; border:2px solid white;"></div>`,
        iconSize: [16,16],
        iconAnchor: [8,8]
      });
    }
    // Compute leg stats between two stops.
    // If both stops have non-null origIndex, sum stage data; otherwise, fallback to haversine.
    function getLegStats(start, end) {
      if(start.origIndex !== null && end.origIndex !== null && start.origIndex !== undefined && end.origIndex !== undefined && end.origIndex > start.origIndex) {
        let totalDistance = 0, totalGain = 0, totalLoss = 0;
        for(let i = start.origIndex; i < end.origIndex; i++){
          totalDistance += stagesN2S[i].distance;
          totalGain += stagesN2S[i].elevationGain;
          totalLoss += stagesN2S[i].elevationLoss;
        }
        return { totalDistance, totalGain, totalLoss };
      } else if(start.alt !== undefined && end.alt !== undefined) {
        const d = haversineDistance(start.lat, start.lng, end.lat, end.lng);
        const gain = Math.max(end.alt - start.alt, 0);
        const loss = Math.max(start.alt - end.alt, 0);
        return { totalDistance: parseFloat(d.toFixed(1)), totalGain: gain, totalLoss: loss };
      } else {
        const d = haversineDistance(start.lat, start.lng, end.lat, end.lng);
        return { totalDistance: parseFloat(d.toFixed(1)), totalGain: "N/A", totalLoss: "N/A" };
      }
    }
    // Basic Naismith estimate.
    function estimateTime(distance, elevationGain) {
      if(elevationGain === "N/A") return "N/A";
      const flatTime = distance / 5;
      const climbTime = (elevationGain / 300) * 0.5;
      const total = flatTime + climbTime;
      const hours = Math.floor(total);
      const minutes = Math.round((total - hours) * 60);
      return `${hours}h ${minutes}m`;
    }

    /******** UI Setup ********/
    function initStopGrid() {
      const grid = document.getElementById("stopGrid");
      grid.innerHTML = "";
      stops.forEach((stop, index) => {
        const btn = document.createElement("button");
        btn.textContent = stop.name;
        btn.setAttribute("data-index", index);
        btn.setAttribute("aria-label", "Stop: " + stop.name);
        btn.addEventListener("click", onStopClick);
        grid.appendChild(btn);
      });
      updateGridSelection();
    }
    function updateGridSelection() {
      const buttons = document.querySelectorAll("#stopGrid button");
      buttons.forEach(btn => {
        const index = parseInt(btn.getAttribute("data-index"));
        if(selectedStops.includes(index)){
          btn.classList.add("selected");
        } else {
          btn.classList.remove("selected");
        }
      });
    }
    function onStopClick(e) {
      const i = parseInt(e.target.getAttribute("data-index"));
      const lastStop = selectedStops[selectedStops.length - 1];
      if(i === lastStop) return;
      if(selectedStops.includes(i)) {
        const pos = selectedStops.indexOf(i);
        selectedStops = selectedStops.slice(0, pos + 1);
      } else {
        if(i > lastStop) {
          selectedStops.push(i);
        } else {
          return;
        }
      }
      updateGridSelection();
      updateItinerary();
    }
    function updateItinerary() {
      const tbody = document.getElementById("itineraryTable");
      tbody.innerHTML = "";
      aggregatedLegs = [];
      for(let k = 0; k < selectedStops.length - 1; k++){
        const start = stops[selectedStops[k]];
        const end = stops[selectedStops[k+1]];
        const stats = getLegStats(start, end);
        const legTime = (stats.totalDistance !== "N/A" && stats.totalGain !== "N/A")
          ? estimateTime(stats.totalDistance, stats.totalGain) : "N/A";
        aggregatedLegs.push({
          startIndex: selectedStops[k],
          endIndex: selectedStops[k+1],
          ...stats,
          legTime,
          combinedHighlights: `${start.name} → ${end.name}`
        });
        const row = document.createElement("tr");
        row.innerHTML = `
          <td>${k+1}</td>
          <td>${start.name}</td>
          <td>${end.name}</td>
          <td>${stats.totalDistance}</td>
          <td>${stats.totalGain}</td>
          <td>${stats.totalLoss}</td>
          <td>${start.name} to ${end.name}</td>
          <td>${legTime}</td>
        `;
        tbody.appendChild(row);
      }
      updateElevationChart();
      updateTimeSummary();
      updateMap();
    }

    /******** Elevation Chart & Time Summary ********/
    let elevationChart; // Declare once.
    function updateElevationChart() {
      let cumulativeDistance = 0;
      const distances = [0];
      const altitudes = [stops[selectedStops[0]].alt || 0];
      for(let i = 1; i < selectedStops.length; i++){
        const prev = stops[selectedStops[i-1]];
        const curr = stops[selectedStops[i]];
        let d;
        if(prev.origIndex !== null && curr.origIndex !== null &&
           prev.origIndex !== undefined && curr.origIndex !== undefined && curr.origIndex > prev.origIndex) {
          d = 0;
          for(let j = prev.origIndex; j < curr.origIndex; j++){
            d += stagesN2S[j].distance;
          }
        } else {
          d = haversineDistance(prev.lat, prev.lng, curr.lat, curr.lng);
        }
        cumulativeDistance += d;
        distances.push(parseFloat(cumulativeDistance.toFixed(1)));
        altitudes.push(curr.alt || 0);
      }
      const ctx = document.getElementById('elevationChart').getContext('2d');
      if(elevationChart) elevationChart.destroy();
      elevationChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: distances,
          datasets: [{
            label: 'Elevation (m)',
            data: altitudes,
            fill: false,
            borderColor: 'orange',
            tension: 0.1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: context => `Elevation: ${context.parsed.y} m`
              }
            }
          },
          scales: {
            x: { title: { display: true, text: 'Cumulative Distance (km)' } },
            y: { title: { display: true, text: 'Altitude (m)' } }
          }
        }
      });
    }
    function updateTimeSummary() {
      let totalMinutes = 0;
      aggregatedLegs.forEach(leg => {
        if(leg.totalDistance !== "N/A" && leg.totalGain !== "N/A"){
          const parts = leg.legTime.split(" ");
          const hours = parseInt(parts[0].replace("h",""));
          const minutes = parseInt(parts[1].replace("m",""));
          totalMinutes += hours * 60 + minutes;
        }
      });
      const totHours = Math.floor(totalMinutes / 60);
      const totMinutes = totalMinutes % 60;
      document.getElementById("timeSummary").innerHTML = `<b>Total Estimated Hiking Time:</b> ${totHours}h ${totMinutes}m`;
    }

    /******** Toggle Stop Display ********/
    document.getElementById("toggleStopDisplay").addEventListener("click", function(){
      showAllStops = !showAllStops;
      this.textContent = showAllStops ? "Show All Stops" : "Show Only Selected Stops";
      updateMap();
    });

    /******** Map Update ********/
    function updateMap() {
      markerLayer.clearLayers();
      legLayer.clearLayers();
      if(showAllStops) {
        stops.forEach((stop, index) => {
          const isSelected = selectedStops.includes(index);
          const marker = L.marker([stop.lat, stop.lng], { icon: getIconForType(stop, isSelected) });
          let extra = "";
          if(stop.type === "refuge" && stop.booking){
            extra = `<br><a href="${stop.booking}" target="_blank">Booking Link</a>`;
          }
          marker.bindPopup(`${stop.name}${extra}`);
          marker.bindTooltip(stop.name, { direction: 'top', permanent: false });
          marker.on('click', async function(e){
            const weather = await fetchWeather(stop.lat, stop.lng);
            this.setPopupContent(`${stop.name}${extra}<br>${weather}`);
          });
          markerLayer.addLayer(marker);
        });
      } else {
        selectedStops.forEach(index => {
          const stop = stops[index];
          const marker = L.marker([stop.lat, stop.lng], { icon: getIconForType(stop, true) });
          let extra = "";
          if(stop.type === "refuge" && stop.booking){
            extra = `<br><a href="${stop.booking}" target="_blank">Booking Link</a>`;
          }
          marker.bindPopup(`${stop.name}${extra}`);
          marker.bindTooltip(stop.name, { direction: 'top', permanent: false });
          marker.on('click', async function(e){
            const weather = await fetchWeather(stop.lat, stop.lng);
            this.setPopupContent(`${stop.name}${extra}<br>${weather}`);
          });
          markerLayer.addLayer(marker);
        });
      }
      aggregatedLegs.forEach(leg => {
        const start = stops[leg.startIndex];
        const end = stops[leg.endIndex];
        const legCoords = [[start.lat, start.lng], [end.lat, end.lng]];
        const polyline = L.polyline(legCoords, { color: 'green', weight: 5, opacity: 0.8 });
        const tooltipContent = `Distance: ${leg.totalDistance} km<br>Elevation Gain: ${leg.totalGain} m<br>Elevation Loss: ${leg.totalLoss} m`;
        polyline.bindTooltip(tooltipContent, {sticky: true});
        legLayer.addLayer(polyline);
      });
      const coordsToFit = selectedStops.map(index => [stops[index].lat, stops[index].lng]);
      if(coordsToFit.length > 0) {
        map.fitBounds(L.latLngBounds(coordsToFit), { padding: [20,20] });
      }
    }

    /******** Weather Integration ********/
    async function fetchWeather(lat, lng) {
      try {
        const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lng}&units=metric&appid=YOUR_API_KEY_HERE`);
        const data = await response.json();
        if(data && data.weather && data.main){
          return `Weather: ${data.weather[0].description}, Temp: ${data.main.temp}°C`;
        }
      } catch(e) {
        console.error(e);
      }
      return "Weather info not available";
    }

    /******** Custom Stops ********/
    map.on('click', function(e) {
      const note = prompt("Enter a note for this custom stop:");
      if(note) {
        const customStop = {
          name: "Custom: " + note,
          type: "custom",
          lat: e.latlng.lat,
          lng: e.latlng.lng,
          alt: 0,
          origIndex: null
        };
        let customStops = JSON.parse(localStorage.getItem("customStops") || "[]");
        customStops.push(customStop);
        localStorage.setItem("customStops", JSON.stringify(customStops));
        stops.push(customStop);
        initStopGrid();
        updateItinerary();
      }
    });
    function loadCustomStops() {
      const customStops = JSON.parse(localStorage.getItem("customStops") || "[]");
      customStops.forEach(cs => {
        if(!stops.find(s => s.name === cs.name)) {
          stops.push(cs);
        }
      });
    }
    loadCustomStops();

    /******** GPX Export ********/
    document.getElementById("exportGPX").addEventListener("click", function(){
      let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GR20 Route Planner" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>GR20 Planned Route</name>
  </metadata>`;
      selectedStops.forEach(index => {
        const stop = stops[index];
        gpx += `
  <wpt lat="${stop.lat}" lon="${stop.lng}">
    <name>${stop.name}</name>
    <desc>Altitude: ${stop.alt || "N/A"} m</desc>
  </wpt>`;
      });
      gpx += `
  <trk>
    <name>GR20 Route</name>
    <trkseg>`;
      selectedStops.forEach(index => {
        const stop = stops[index];
        gpx += `
      <trkpt lat="${stop.lat}" lon="${stop.lng}">
        <ele>${stop.alt || 0}</ele>
      </trkpt>`;
      });
      gpx += `
    </trkseg>
  </trk>
</gpx>`;
      const blob = new Blob([gpx], { type: "application/gpx+xml" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "GR20_route.gpx";
      a.click();
      URL.revokeObjectURL(url);
    });

    /******** Elevation Chart & Time Summary ********/
    function updateElevationChart() {
      let cumulativeDistance = 0;
      const distances = [0];
      const altitudes = [stops[selectedStops[0]].alt || 0];
      for(let i = 1; i < selectedStops.length; i++){
        const prev = stops[selectedStops[i-1]];
        const curr = stops[selectedStops[i]];
        let d;
        if(prev.origIndex !== null && curr.origIndex !== null &&
           prev.origIndex !== undefined && curr.origIndex !== undefined && curr.origIndex > prev.origIndex) {
          d = 0;
          for(let j = prev.origIndex; j < curr.origIndex; j++){
            d += stagesN2S[j].distance;
          }
        } else {
          d = haversineDistance(prev.lat, prev.lng, curr.lat, curr.lng);
        }
        cumulativeDistance += d;
        distances.push(parseFloat(cumulativeDistance.toFixed(1)));
        altitudes.push(curr.alt || 0);
      }
      const ctx = document.getElementById('elevationChart').getContext('2d');
      if(elevationChart) elevationChart.destroy();
      elevationChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: distances,
          datasets: [{
            label: 'Elevation (m)',
            data: altitudes,
            fill: false,
            borderColor: 'orange',
            tension: 0.1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: context => `Elevation: ${context.parsed.y} m`
              }
            }
          },
          scales: {
            x: { title: { display: true, text: 'Cumulative Distance (km)' } },
            y: { title: { display: true, text: 'Altitude (m)' } }
          }
        }
      });
    }
    function updateTimeSummary() {
      let totalMinutes = 0;
      aggregatedLegs.forEach(leg => {
        if(leg.totalDistance !== "N/A" && leg.totalGain !== "N/A"){
          const parts = leg.legTime.split(" ");
          const hours = parseInt(parts[0].replace("h",""));
          const minutes = parseInt(parts[1].replace("m",""));
          totalMinutes += hours * 60 + minutes;
        }
      });
      const totHours = Math.floor(totalMinutes / 60);
      const totMinutes = totalMinutes % 60;
      document.getElementById("timeSummary").innerHTML = `<b>Total Estimated Hiking Time:</b> ${totHours}h ${totMinutes}m`;
    }

    /******** Map Setup ********/
    const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: 'OSM' });
    const satelliteLayer = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: 'Esri World Imagery' });
    let map = L.map('map', { layers: [osmLayer] }).setView([42.64, 8.75], 11);
    const baseLayers = { "OSM Standard": osmLayer, "Satellite": satelliteLayer };
    L.control.layers(baseLayers).addTo(map);
    let markerLayer = L.layerGroup().addTo(map);
    let legLayer = L.layerGroup().addTo(map);

    /******** Toggle Stop Display ********/
    document.getElementById("toggleStopDisplay").addEventListener("click", function(){
      showAllStops = !showAllStops;
      this.textContent = showAllStops ? "Show All Stops" : "Show Only Selected Stops";
      updateMap();
    });

    /******** Map Update ********/
    function updateMap() {
      markerLayer.clearLayers();
      legLayer.clearLayers();
      if(showAllStops) {
        stops.forEach((stop, index) => {
          const isSelected = selectedStops.includes(index);
          const marker = L.marker([stop.lat, stop.lng], { icon: getIconForType(stop, isSelected) });
          let extra = "";
          if(stop.type === "refuge" && stop.booking){
            extra = `<br><a href="${stop.booking}" target="_blank">Booking Link</a>`;
          }
          marker.bindPopup(`${stop.name}${extra}`);
          marker.bindTooltip(stop.name, { direction: 'top', permanent: false });
          marker.on('click', async function(e){
            const weather = await fetchWeather(stop.lat, stop.lng);
            this.setPopupContent(`${stop.name}${extra}<br>${weather}`);
          });
          markerLayer.addLayer(marker);
        });
      } else {
        selectedStops.forEach(index => {
          const stop = stops[index];
          const marker = L.marker([stop.lat, stop.lng], { icon: getIconForType(stop, true) });
          let extra = "";
          if(stop.type === "refuge" && stop.booking){
            extra = `<br><a href="${stop.booking}" target="_blank">Booking Link</a>`;
          }
          marker.bindPopup(`${stop.name}${extra}`);
          marker.bindTooltip(stop.name, { direction: 'top', permanent: false });
          marker.on('click', async function(e){
            const weather = await fetchWeather(stop.lat, stop.lng);
            this.setPopupContent(`${stop.name}${extra}<br>${weather}`);
          });
          markerLayer.addLayer(marker);
        });
      }
      aggregatedLegs.forEach(leg => {
        const start = stops[leg.startIndex];
        const end = stops[leg.endIndex];
        const legCoords = [[start.lat, start.lng], [end.lat, end.lng]];
        const polyline = L.polyline(legCoords, { color: 'green', weight: 5, opacity: 0.8 });
        const tooltipContent = `Distance: ${leg.totalDistance} km<br>Elevation Gain: ${leg.totalGain} m<br>Elevation Loss: ${leg.totalLoss} m`;
        polyline.bindTooltip(tooltipContent, {sticky: true});
        legLayer.addLayer(polyline);
      });
      const coordsToFit = selectedStops.map(index => [stops[index].lat, stops[index].lng]);
      if(coordsToFit.length > 0) {
        map.fitBounds(L.latLngBounds(coordsToFit), { padding: [20,20] });
      }
    }

    /******** Weather Integration ********/
    async function fetchWeather(lat, lng) {
      try {
        const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lng}&units=metric&appid=YOUR_API_KEY_HERE`);
        const data = await response.json();
        if(data && data.weather && data.main){
          return `Weather: ${data.weather[0].description}, Temp: ${data.main.temp}°C`;
        }
      } catch(e) {
        console.error(e);
      }
      return "Weather info not available";
    }

    /******** Custom Stops ********/
    map.on('click', function(e) {
      const note = prompt("Enter a note for this custom stop:");
      if(note) {
        const customStop = {
          name: "Custom: " + note,
          type: "custom",
          lat: e.latlng.lat,
          lng: e.latlng.lng,
          alt: 0,
          origIndex: null
        };
        let customStops = JSON.parse(localStorage.getItem("customStops") || "[]");
        customStops.push(customStop);
        localStorage.setItem("customStops", JSON.stringify(customStops));
        stops.push(customStop);
        initStopGrid();
        updateItinerary();
      }
    });
    function loadCustomStops() {
      const customStops = JSON.parse(localStorage.getItem("customStops") || "[]");
      customStops.forEach(cs => {
        if(!stops.find(s => s.name === cs.name)) {
          stops.push(cs);
        }
      });
    }
    loadCustomStops();

    /******** GPX Export ********/
    document.getElementById("exportGPX").addEventListener("click", function(){
      let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GR20 Route Planner" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>GR20 Planned Route</name>
  </metadata>`;
      selectedStops.forEach(index => {
        const stop = stops[index];
        gpx += `
  <wpt lat="${stop.lat}" lon="${stop.lng}">
    <name>${stop.name}</name>
    <desc>Altitude: ${stop.alt || "N/A"} m</desc>
  </wpt>`;
      });
      gpx += `
  <trk>
    <name>GR20 Route</name>
    <trkseg>`;
      selectedStops.forEach(index => {
        const stop = stops[index];
        gpx += `
      <trkpt lat="${stop.lat}" lon="${stop.lng}">
        <ele>${stop.alt || 0}</ele>
      </trkpt>`;
      });
      gpx += `
    </trkseg>
  </trk>
</gpx>`;
      const blob = new Blob([gpx], { type: "application/gpx+xml" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "GR20_route.gpx";
      a.click();
      URL.revokeObjectURL(url);
    });

    /******** Elevation Chart & Time Summary ********/
    function updateElevationChart() {
      let cumulativeDistance = 0;
      const distances = [0];
      const altitudes = [stops[selectedStops[0]].alt || 0];
      for(let i = 1; i < selectedStops.length; i++){
        const prev = stops[selectedStops[i-1]];
        const curr = stops[selectedStops[i]];
        let d;
        if(prev.origIndex !== null && curr.origIndex !== null &&
           prev.origIndex !== undefined && curr.origIndex !== undefined && curr.origIndex > prev.origIndex) {
          d = 0;
          for(let j = prev.origIndex; j < curr.origIndex; j++){
            d += stagesN2S[j].distance;
          }
        } else {
          d = haversineDistance(prev.lat, prev.lng, curr.lat, curr.lng);
        }
        cumulativeDistance += d;
        distances.push(parseFloat(cumulativeDistance.toFixed(1)));
        altitudes.push(curr.alt || 0);
      }
      const ctx = document.getElementById('elevationChart').getContext('2d');
      if(elevationChart) elevationChart.destroy();
      elevationChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: distances,
          datasets: [{
            label: 'Elevation (m)',
            data: altitudes,
            fill: false,
            borderColor: 'orange',
            tension: 0.1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: context => `Elevation: ${context.parsed.y} m`
              }
            }
          },
          scales: {
            x: { title: { display: true, text: 'Cumulative Distance (km)' } },
            y: { title: { display: true, text: 'Altitude (m)' } }
          }
        }
      });
    }
    function updateTimeSummary() {
      let totalMinutes = 0;
      aggregatedLegs.forEach(leg => {
        if(leg.totalDistance !== "N/A" && leg.totalGain !== "N/A"){
          const parts = leg.legTime.split(" ");
          const hours = parseInt(parts[0].replace("h",""));
          const minutes = parseInt(parts[1].replace("m",""));
          totalMinutes += hours * 60 + minutes;
        }
      });
      const totHours = Math.floor(totalMinutes / 60);
      const totMinutes = totalMinutes % 60;
      document.getElementById("timeSummary").innerHTML = `<b>Total Estimated Hiking Time:</b> ${totHours}h ${totMinutes}m`;
    }

    /******** Toggle Stop Display ********/
    document.getElementById("toggleStopDisplay").addEventListener("click", function(){
      showAllStops = !showAllStops;
      this.textContent = showAllStops ? "Show All Stops" : "Show Only Selected Stops";
      updateMap();
    });

    /******** Map Update ********/
    function updateMap() {
      markerLayer.clearLayers();
      legLayer.clearLayers();
      if(showAllStops) {
        stops.forEach((stop, index) => {
          const isSelected = selectedStops.includes(index);
          const marker = L.marker([stop.lat, stop.lng], { icon: getIconForType(stop, isSelected) });
          let extra = "";
          if(stop.type === "refuge" && stop.booking){
            extra = `<br><a href="${stop.booking}" target="_blank">Booking Link</a>`;
          }
          marker.bindPopup(`${stop.name}${extra}`);
          marker.bindTooltip(stop.name, { direction: 'top', permanent: false });
          marker.on('click', async function(e){
            const weather = await fetchWeather(stop.lat, stop.lng);
            this.setPopupContent(`${stop.name}${extra}<br>${weather}`);
          });
          markerLayer.addLayer(marker);
        });
      } else {
        selectedStops.forEach(index => {
          const stop = stops[index];
          const marker = L.marker([stop.lat, stop.lng], { icon: getIconForType(stop, true) });
          let extra = "";
          if(stop.type === "refuge" && stop.booking){
            extra = `<br><a href="${stop.booking}" target="_blank">Booking Link</a>`;
          }
          marker.bindPopup(`${stop.name}${extra}`);
          marker.bindTooltip(stop.name, { direction: 'top', permanent: false });
          marker.on('click', async function(e){
            const weather = await fetchWeather(stop.lat, stop.lng);
            this.setPopupContent(`${stop.name}${extra}<br>${weather}`);
          });
          markerLayer.addLayer(marker);
        });
      }
      aggregatedLegs.forEach(leg => {
        const start = stops[leg.startIndex];
        const end = stops[leg.endIndex];
        const legCoords = [[start.lat, start.lng], [end.lat, end.lng]];
        const polyline = L.polyline(legCoords, { color: 'green', weight: 5, opacity: 0.8 });
        const tooltipContent = `Distance: ${leg.totalDistance} km<br>Elevation Gain: ${leg.totalGain} m<br>Elevation Loss: ${leg.totalLoss} m`;
        polyline.bindTooltip(tooltipContent, {sticky: true});
        legLayer.addLayer(polyline);
      });
      const coordsToFit = selectedStops.map(index => [stops[index].lat, stops[index].lng]);
      if(coordsToFit.length > 0) {
        map.fitBounds(L.latLngBounds(coordsToFit), { padding: [20,20] });
      }
    }

    /******** Weather Integration ********/
    async function fetchWeather(lat, lng) {
      try {
        const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lng}&units=metric&appid=YOUR_API_KEY_HERE`);
        const data = await response.json();
        if(data && data.weather && data.main){
          return `Weather: ${data.weather[0].description}, Temp: ${data.main.temp}°C`;
        }
      } catch(e) {
        console.error(e);
      }
      return "Weather info not available";
    }

    /******** Custom Stops ********/
    map.on('click', function(e) {
      const note = prompt("Enter a note for this custom stop:");
      if(note) {
        const customStop = {
          name: "Custom: " + note,
          type: "custom",
          lat: e.latlng.lat,
          lng: e.latlng.lng,
          alt: 0,
          origIndex: null
        };
        let customStops = JSON.parse(localStorage.getItem("customStops") || "[]");
        customStops.push(customStop);
        localStorage.setItem("customStops", JSON.stringify(customStops));
        stops.push(customStop);
        initStopGrid();
        updateItinerary();
      }
    });
    function loadCustomStops() {
      const customStops = JSON.parse(localStorage.getItem("customStops") || "[]");
      customStops.forEach(cs => {
        if(!stops.find(s => s.name === cs.name)) {
          stops.push(cs);
        }
      });
    }
    loadCustomStops();

    /******** GPX Export ********/
    document.getElementById("exportGPX").addEventListener("click", function(){
      let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GR20 Route Planner" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>GR20 Planned Route</name>
  </metadata>`;
      selectedStops.forEach(index => {
        const stop = stops[index];
        gpx += `
  <wpt lat="${stop.lat}" lon="${stop.lng}">
    <name>${stop.name}</name>
    <desc>Altitude: ${stop.alt || "N/A"} m</desc>
  </wpt>`;
      });
      gpx += `
  <trk>
    <name>GR20 Route</name>
    <trkseg>`;
      selectedStops.forEach(index => {
        const stop = stops[index];
        gpx += `
      <trkpt lat="${stop.lat}" lon="${stop.lng}">
        <ele>${stop.alt || 0}</ele>
      </trkpt>`;
      });
      gpx += `
    </trkseg>
  </trk>
</gpx>`;
      const blob = new Blob([gpx], { type: "application/gpx+xml" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "GR20_route.gpx";
      a.click();
      URL.revokeObjectURL(url);
    });

    /******** Elevation Chart & Time Summary ********/
    function updateElevationChart() {
      let cumulativeDistance = 0;
      const distances = [0];
      const altitudes = [stops[selectedStops[0]].alt || 0];
      for(let i = 1; i < selectedStops.length; i++){
        const prev = stops[selectedStops[i-1]];
        const curr = stops[selectedStops[i]];
        let d;
        if(prev.origIndex !== null && curr.origIndex !== null &&
           prev.origIndex !== undefined && curr.origIndex !== undefined && curr.origIndex > prev.origIndex) {
          d = 0;
          for(let j = prev.origIndex; j < curr.origIndex; j++){
            d += stagesN2S[j].distance;
          }
        } else {
          d = haversineDistance(prev.lat, prev.lng, curr.lat, curr.lng);
        }
        cumulativeDistance += d;
        distances.push(parseFloat(cumulativeDistance.toFixed(1)));
        altitudes.push(curr.alt || 0);
      }
      const ctx = document.getElementById('elevationChart').getContext('2d');
      if(elevationChart) elevationChart.destroy();
      elevationChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: distances,
          datasets: [{
            label: 'Elevation (m)',
            data: altitudes,
            fill: false,
            borderColor: 'orange',
            tension: 0.1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: context => `Elevation: ${context.parsed.y} m`
              }
            }
          },
          scales: {
            x: { title: { display: true, text: 'Cumulative Distance (km)' } },
            y: { title: { display: true, text: 'Altitude (m)' } }
          }
        }
      });
    }
    function updateTimeSummary() {
      let totalMinutes = 0;
      aggregatedLegs.forEach(leg => {
        if(leg.totalDistance !== "N/A" && leg.totalGain !== "N/A"){
          const parts = leg.legTime.split(" ");
          const hours = parseInt(parts[0].replace("h",""));
          const minutes = parseInt(parts[1].replace("m",""));
          totalMinutes += hours * 60 + minutes;
        }
      });
      const totHours = Math.floor(totalMinutes / 60);
      const totMinutes = totalMinutes % 60;
      document.getElementById("timeSummary").innerHTML = `<b>Total Estimated Hiking Time:</b> ${totHours}h ${totMinutes}m`;
    }

    /******** Toggle Stop Display ********/
    document.getElementById("toggleStopDisplay").addEventListener("click", function(){
      showAllStops = !showAllStops;
      this.textContent = showAllStops ? "Show All Stops" : "Show Only Selected Stops";
      updateMap();
    });

    /******** Map Update ********/
    function updateMap() {
      markerLayer.clearLayers();
      legLayer.clearLayers();
      if(showAllStops) {
        stops.forEach((stop, index) => {
          const isSelected = selectedStops.includes(index);
          const marker = L.marker([stop.lat, stop.lng], { icon: getIconForType(stop, isSelected) });
          let extra = "";
          if(stop.type === "refuge" && stop.booking){
            extra = `<br><a href="${stop.booking}" target="_blank">Booking Link</a>`;
          }
          marker.bindPopup(`${stop.name}${extra}`);
          marker.bindTooltip(stop.name, { direction: 'top', permanent: false });
          marker.on('click', async function(e){
            const weather = await fetchWeather(stop.lat, stop.lng);
            this.setPopupContent(`${stop.name}${extra}<br>${weather}`);
          });
          markerLayer.addLayer(marker);
        });
      } else {
        selectedStops.forEach(index => {
          const stop = stops[index];
          const marker = L.marker([stop.lat, stop.lng], { icon: getIconForType(stop, true) });
          let extra = "";
          if(stop.type === "refuge" && stop.booking){
            extra = `<br><a href="${stop.booking}" target="_blank">Booking Link</a>`;
          }
          marker.bindPopup(`${stop.name}${extra}`);
          marker.bindTooltip(stop.name, { direction: 'top', permanent: false });
          marker.on('click', async function(e){
            const weather = await fetchWeather(stop.lat, stop.lng);
            this.setPopupContent(`${stop.name}${extra}<br>${weather}`);
          });
          markerLayer.addLayer(marker);
        });
      }
      aggregatedLegs.forEach(leg => {
        const start = stops[leg.startIndex];
        const end = stops[leg.endIndex];
        const legCoords = [[start.lat, start.lng], [end.lat, end.lng]];
        const polyline = L.polyline(legCoords, { color: 'green', weight: 5, opacity: 0.8 });
        const tooltipContent = `Distance: ${leg.totalDistance} km<br>Elevation Gain: ${leg.totalGain} m<br>Elevation Loss: ${leg.totalLoss} m`;
        polyline.bindTooltip(tooltipContent, {sticky: true});
        legLayer.addLayer(polyline);
      });
      const coordsToFit = selectedStops.map(index => [stops[index].lat, stops[index].lng]);
      if(coordsToFit.length > 0) {
        map.fitBounds(L.latLngBounds(coordsToFit), { padding: [20,20] });
      }
    }

    /******** Weather Integration ********/
    async function fetchWeather(lat, lng) {
      try {
        const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lng}&units=metric&appid=YOUR_API_KEY_HERE`);
        const data = await response.json();
        if(data && data.weather && data.main){
          return `Weather: ${data.weather[0].description}, Temp: ${data.main.temp}°C`;
        }
      } catch(e) {
        console.error(e);
      }
      return "Weather info not available";
    }

    /******** Custom Stops ********/
    map.on('click', function(e) {
      const note = prompt("Enter a note for this custom stop:");
      if(note) {
        const customStop = {
          name: "Custom: " + note,
          type: "custom",
          lat: e.latlng.lat,
          lng: e.latlng.lng,
          alt: 0,
          origIndex: null
        };
        let customStops = JSON.parse(localStorage.getItem("customStops") || "[]");
        customStops.push(customStop);
        localStorage.setItem("customStops", JSON.stringify(customStops));
        stops.push(customStop);
        initStopGrid();
        updateItinerary();
      }
    });
    function loadCustomStops() {
      const customStops = JSON.parse(localStorage.getItem("customStops") || "[]");
      customStops.forEach(cs => {
        if(!stops.find(s => s.name === cs.name)) {
          stops.push(cs);
        }
      });
    }
    loadCustomStops();

    /******** GPX Export ********/
    document.getElementById("exportGPX").addEventListener("click", function(){
      let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="GR20 Route Planner" xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>GR20 Planned Route</name>
  </metadata>`;
      selectedStops.forEach(index => {
        const stop = stops[index];
        gpx += `
  <wpt lat="${stop.lat}" lon="${stop.lng}">
    <name>${stop.name}</name>
    <desc>Altitude: ${stop.alt || "N/A"} m</desc>
  </wpt>`;
      });
      gpx += `
  <trk>
    <name>GR20 Route</name>
    <trkseg>`;
      selectedStops.forEach(index => {
        const stop = stops[index];
        gpx += `
      <trkpt lat="${stop.lat}" lon="${stop.lng}">
        <ele>${stop.alt || 0}</ele>
      </trkpt>`;
      });
      gpx += `
    </trkseg>
  </trk>
</gpx>`;
      const blob = new Blob([gpx], { type: "application/gpx+xml" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "GR20_route.gpx";
      a.click();
      URL.revokeObjectURL(url);
    });

    /******** Elevation Chart & Time Summary ********/
    function updateElevationChart() {
      let cumulativeDistance = 0;
      const distances = [0];
      const altitudes = [stops[selectedStops[0]].alt || 0];
      for(let i = 1; i < selectedStops.length; i++){
        const prev = stops[selectedStops[i-1]];
        const curr = stops[selectedStops[i]];
        let d;
        if(prev.origIndex !== null && curr.origIndex !== null &&
           prev.origIndex !== undefined && curr.origIndex !== undefined && curr.origIndex > prev.origIndex) {
          d = 0;
          for(let j = prev.origIndex; j < curr.origIndex; j++){
            d += stagesN2S[j].distance;
          }
        } else {
          d = haversineDistance(prev.lat, prev.lng, curr.lat, curr.lng);
        }
        cumulativeDistance += d;
        distances.push(parseFloat(cumulativeDistance.toFixed(1)));
        altitudes.push(curr.alt || 0);
      }
      const ctx = document.getElementById('elevationChart').getContext('2d');
      if(elevationChart) elevationChart.destroy();
      elevationChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: distances,
          datasets: [{
            label: 'Elevation (m)',
            data: altitudes,
            fill: false,
            borderColor: 'orange',
            tension: 0.1
          }]
        },
        options: {
          responsive: true,
          plugins: {
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: context => `Elevation: ${context.parsed.y} m`
              }
            }
          },
          scales: {
            x: { title: { display: true, text: 'Cumulative Distance (km)' } },
            y: { title: { display: true, text: 'Altitude (m)' } }
          }
        }
      });
    }
    function updateTimeSummary() {
      let totalMinutes = 0;
      aggregatedLegs.forEach(leg => {
        if(leg.totalDistance !== "N/A" && leg.totalGain !== "N/A"){
          const parts = leg.legTime.split(" ");
          const hours = parseInt(parts[0].replace("h",""));
          const minutes = parseInt(parts[1].replace("m",""));
          totalMinutes += hours * 60 + minutes;
        }
      });
      const totHours = Math.floor(totalMinutes / 60);
      const totMinutes = totalMinutes % 60;
      document.getElementById("timeSummary").innerHTML = `<b>Total Estimated Hiking Time:</b> ${totHours}h ${totMinutes}m`;
    }

    /******** Direction Change ********/
    document.getElementById("direction").addEventListener("change", function(e) {
      currentDirection = e.target.value;
      if(currentDirection === "N2S"){
        stops = [...stopsN2SExtended];
      } else {
        stops = [...stopsN2SExtended].reverse();
      }
      selectedStops = [0];
      initStopGrid();
      updateItinerary();
    });

    // Initial setup.
    initStopGrid();
    updateItinerary();

    // Add legend to map.
    var legend = L.control({position: 'bottomright'});
    legend.onAdd = function(map) {
      var div = L.DomUtil.create('div', 'info legend');
      div.innerHTML += "<b>Legend</b><br>";
      div.innerHTML += '<i style="background: red"></i> Refuge (Selected)<br>';
      div.innerHTML += '<i style="background: blue"></i> Refuge (Default)<br>';
      div.innerHTML += '<i style="background: black"></i> Village (Selected)<br>';
      div.innerHTML += '<i style="background: gray"></i> Village (Default)<br>';
      div.innerHTML += '<i style="background: darkorange"></i> Sheepfold (Selected)<br>';
      div.innerHTML += '<i style="background: orange"></i> Sheepfold (Default)<br>';
      div.innerHTML += '<i style="background: violet"></i> Custom Stop<br>';
      return div;
    };
    legend.addTo(map);
  </script>
</body>
</html>
